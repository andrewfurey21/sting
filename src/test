pseudo code for recusive descent

class Parser {
	Token current = tokens[index];
	Token previous;
	u64 index = 0;
}

class Expression
class Binary
class Unary
class Literal
class Grouping

bool Parser::at_end() {
	return current.type == END_OF_FILE;
}

bool Parser::match(TokenType... types) {
	for (TokenType type : types) {
		if (current.type == type && !at_end) return true;
	}
	return false;
}

bool Parser::advance() {
	if (at_end) return false;
	previous = current;
	current = tokens[++index];
	return true;
}

void Parser::consume(TokenType type, const char* msg) {
	advance();
	if (current.type != type) error(msg);
}

Expression Parser::expression() {
	return equality();
}

Expression Parser::equality() {
	Expression left = comparison();

	while (match(BANG_EQUAL, EQUAL_EQUAL)) {
		Token op = current;
		advance();
		Expression right = comparsion();
		left = Binary(op, left, right);
	}

	return left;
}

Expression Parser::comparison() {
	Expression left = plus_minus();
	while (match(GREATER_EQUAL, LESS_EQUAL, ...)) {
		Token op = current;
		advance();
		Expression right = plus_minus();
		left = Binary(op, left, right);
	}

	return left;
}

Expression Parser::plus_minus() {
	Expression left = divide_multiply();
	while (match(MINUS, PLUS)) {
		Token op = current;
		advance();
		Expression right = divide_multiply();
		left = Binary(op, left, right);
	}
	return left;
}

Expression Parser::divide_multiply() {
	Expression left = unary();
	while (match(SLASH, STAR)) {
		Token op = current;
		advance();
		Expression right = unary();
		left = Binary(op, left, right);
	}
	return left;
}

Expression Parser::unary() {
	if (match(MINUS, BANG)) {
		Token op = current;
		advance();
		Expression unary = unary();
		return Unary(op, unary);
	}
	return primary();
}

Expression Parser::primary() {
	Expression result;
	if (match(FALSE)) result = Literal(false);
	if (match(TRUE)) result = Literal(true);
	if (match(NIL)) result = Literall(null);

	if (match(NUMBER, STRING)) result = Literal(current.start);

	if (match(LEFT_PAREN)) {
		result = expression();
		consume(RIGHT_PAREN, "Expected ')' after expression);
		result = Grouping(result);
	}

	advance();
	return result;
}
