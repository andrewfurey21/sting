# parsing

Takes the tokens created by the lexer and transforms them into a more complex representation.

A workable representation of our code is a tree that matches the grammatical structure of the code.

In the syntactic grammar for the language, each letter is a token that was generated by the lexer. A string is an sequence of tokens.

* Characters -> Scanner -> Token
* Tokens -> Parser -> Expression

Backus-Naur form: notation used to describe context free grammars. <symbol> = <expression>.

This is an exerpt from crafting interpreters talkin about a notation for describing cfg
```
breakfast → protein ( "with" breakfast "on the side" )?
          | bread ;

protein   → "really"+ "crispy" "bacon"
          | "sausage"
          | ( "scrambled" | "poached" | "fried" ) "eggs" ;

bread     → "toast" | "biscuits" | "English muffin" ;
```

The symbols are entire tokens not just characters.

Beginning grammar for 1 - (2 * 3) < 4 == false:
```
expression →  literal | unary | binary | grouping;

literal →  NUMBER | STRING | "true" | "false" | "nil";
grouping → "(" expression ")";
unary →  ("-" | "!") expression;
binary →  expression (compare | operator) expression
compare →  "==" | ">=" | "<=" | "<" | ">" | "!=";
operator →  "+" | "*" | "/" | "-";
```

A parse tree has all production rules as a node in the tree. in an abstract syntax tree, productions are omitted that aren't need by later phases.

Visitor pattern



